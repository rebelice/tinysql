!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/yang/PingCAP/TinySQL/server/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	/p5.9.20210110.0/
Attrs	conn.go	/^	Attrs      map[string]string$/;"	m	struct:server.handshakeResponse41	typeref:typename:map[string]string
Auth	conn.go	/^	Auth       []byte$/;"	m	struct:server.handshakeResponse41	typeref:typename:[]byte
AuthPlugin	conn.go	/^	AuthPlugin string$/;"	m	struct:server.handshakeResponse41	typeref:typename:string
Capability	conn.go	/^	Capability uint32$/;"	m	struct:server.handshakeResponse41	typeref:typename:uint32
Close	conn.go	/^func (cc *clientConn) Close() error {$/;"	f	struct:server.clientConn	typeref:typename:error
Collation	conn.go	/^	Collation  uint8$/;"	m	struct:server.handshakeResponse41	typeref:typename:uint8
Conn	buffered_read_conn.go	/^	net.Conn$/;"	M	struct:server.bufferedReadConn	typeref:typename:net.Conn
DBName	conn.go	/^	DBName     string$/;"	m	struct:server.handshakeResponse41	typeref:typename:string
NewServer	server.go	/^func NewServer() (*Server, error) {$/;"	f	package:server	typeref:typename:(*Server, error)
PProfLabel	conn.go	/^func (cc getLastStmtInConn) PProfLabel() string {$/;"	f	struct:server.getLastStmtInConn	typeref:typename:string
PeerHost	conn.go	/^func (cc *clientConn) PeerHost(hasPassword string) (host, port string, err error) {$/;"	f	struct:server.clientConn	typeref:typename:(host, port string, err error)
Read	buffered_read_conn.go	/^func (conn bufferedReadConn) Read(b []byte) (n int, err error) {$/;"	f	struct:server.bufferedReadConn	typeref:typename:(n int, err error)
Run	conn.go	/^func (cc *clientConn) Run(ctx context.Context) {$/;"	f	struct:server.clientConn
Run	server.go	/^func (s *Server) Run() error {$/;"	f	struct:server.Server	typeref:typename:error
Server	server.go	/^type Server struct {$/;"	s	package:server
SessionStatusToString	conn.go	/^func (cc *clientConn) SessionStatusToString() string {$/;"	f	struct:server.clientConn	typeref:typename:string
ShutdownOrNotify	conn.go	/^func (cc *clientConn) ShutdownOrNotify() bool {$/;"	f	struct:server.clientConn	typeref:typename:bool
String	conn.go	/^func (cc *clientConn) String() string {$/;"	f	struct:server.clientConn	typeref:typename:string
String	conn.go	/^func (cc getLastStmtInConn) String() string {$/;"	f	struct:server.getLastStmtInConn	typeref:typename:string
User	conn.go	/^	User       string$/;"	m	struct:server.handshakeResponse41	typeref:typename:string
addMetrics	conn.go	/^func (cc *clientConn) addMetrics(cmd byte, startTime time.Time, err error) {$/;"	f	struct:server.clientConn
alloc	conn.go	/^	alloc        arena.Allocator   \/\/ an memory allocator for reducing memory allocation.$/;"	m	struct:server.clientConn	typeref:typename:arena.Allocator
attrs	conn.go	/^	attrs        map[string]string \/\/ attributes parsed from client handshake response, not used /;"	m	struct:server.clientConn	typeref:typename:map[string]string
audit	conn.go	/^func (cc *clientConn) audit(eventType plugin.GeneralEvent) {$/;"	f	struct:server.clientConn
authPlugin	conn.go	/^	authPlugin   string            \/\/ default authentication plugin$/;"	m	struct:server.clientConn	typeref:typename:string
authSha	conn.go	/^func (cc *clientConn) authSha(ctx context.Context) ([]byte, error) {$/;"	f	struct:server.clientConn	typeref:typename:([]byte, error)
authSwitchRequest	conn.go	/^func (cc *clientConn) authSwitchRequest(ctx context.Context, plugin string) ([]byte, error) {$/;"	f	struct:server.clientConn	typeref:typename:([]byte, error)
bufReadConn	conn.go	/^	bufReadConn  *bufferedReadConn \/\/ a buffered-read net.Conn or buffered-read tls.Conn.$/;"	m	struct:server.clientConn	typeref:typename:*bufferedReadConn
bufReadConn	packetio.go	/^	bufReadConn *bufferedReadConn$/;"	m	struct:server.packetIO	typeref:typename:*bufferedReadConn
bufWriter	packetio.go	/^	bufWriter   *bufio.Writer$/;"	m	struct:server.packetIO	typeref:typename:*bufio.Writer
bufferedReadConn	buffered_read_conn.go	/^type bufferedReadConn struct {$/;"	s	package:server
capability	conn.go	/^	capability   uint32            \/\/ client capability affects the way server handles client req/;"	m	struct:server.clientConn	typeref:typename:uint32
cfg	server.go	/^	cfg				*config.Config$/;"	m	struct:server.Server	typeref:typename:*config.Config
checkAuthPlugin	conn.go	/^func (cc *clientConn) checkAuthPlugin(ctx context.Context, authPlugin *string) ([]byte, error) {$/;"	f	struct:server.clientConn	typeref:typename:([]byte, error)
clientConn	conn.go	/^	*clientConn$/;"	M	struct:server.getLastStmtInConn	typeref:typename:*clientConn
clientConn	conn.go	/^type clientConn struct {$/;"	s	package:server
closeConn	conn.go	/^func closeConn(cc *clientConn, connections int) error {$/;"	f	package:server	typeref:typename:error
closeWithoutLock	conn.go	/^func (cc *clientConn) closeWithoutLock() error {$/;"	f	struct:server.clientConn	typeref:typename:error
collation	conn.go	/^	collation    uint8             \/\/ collation used by client, may be different from the collati/;"	m	struct:server.clientConn	typeref:typename:uint8
connIdleDurationHistogramInTxn	conn.go	/^	connIdleDurationHistogramInTxn    = metrics.ConnIdleDurationHistogram.WithLabelValues("1")$/;"	v	package:server
connIdleDurationHistogramNotInTxn	conn.go	/^	connIdleDurationHistogramNotInTxn = metrics.ConnIdleDurationHistogram.WithLabelValues("0")$/;"	v	package:server
connStatusDispatching	conn.go	/^	connStatusDispatching int32 = iota$/;"	c	package:server	typeref:typename:int32
connStatusReading	conn.go	/^	connStatusReading$/;"	c	package:server
connStatusShutdown	conn.go	/^	connStatusShutdown     \/\/ Closed by server.$/;"	c	package:server
connStatusWaitShutdown	conn.go	/^	connStatusWaitShutdown \/\/ Notified by server to close.$/;"	c	package:server
connectionID	conn.go	/^	connectionID uint64            \/\/ atomically allocated by a global variable, unique in proces/;"	m	struct:server.clientConn	typeref:typename:uint64
ctx	conn.go	/^	ctx          *TiDBContext      \/\/ an interface to execute sql statements.$/;"	m	struct:server.clientConn	typeref:typename:*TiDBContext
dbname	conn.go	/^	dbname       string            \/\/ default database name.$/;"	m	struct:server.clientConn	typeref:typename:string
defaultReaderSize	buffered_read_conn.go	/^const defaultReaderSize = 16 * 1024$/;"	c	package:server
defaultWriterSize	packetio.go	/^const defaultWriterSize = 16 * 1024$/;"	c	package:server
disconnectByClientWithError	conn.go	/^	disconnectByClientWithError = metrics.DisconnectionCounter.WithLabelValues(metrics.LblError)$/;"	v	package:server
disconnectErrorUndetermined	conn.go	/^	disconnectErrorUndetermined = metrics.DisconnectionCounter.WithLabelValues("undetermined")$/;"	v	package:server
disconnectNormal	conn.go	/^	disconnectNormal            = metrics.DisconnectionCounter.WithLabelValues(metrics.LblOK)$/;"	v	package:server
dispatch	conn.go	/^func (cc *clientConn) dispatch(ctx context.Context, data []byte) error {$/;"	f	struct:server.clientConn	typeref:typename:error
errStrForLog	conn.go	/^func errStrForLog(err error, enableRedactLog bool) string {$/;"	f	package:server	typeref:typename:string
flush	conn.go	/^func (cc *clientConn) flush(ctx context.Context) error {$/;"	f	struct:server.clientConn	typeref:typename:error
getDataFromPath	conn.go	/^func (cc *clientConn) getDataFromPath(ctx context.Context, path string) ([]byte, error) {$/;"	f	struct:server.clientConn	typeref:typename:([]byte, error)
getLastStmtInConn	conn.go	/^type getLastStmtInConn struct {$/;"	s	package:server
getSessionVarsWaitTimeout	conn.go	/^func (cc *clientConn) getSessionVarsWaitTimeout(ctx context.Context) uint64 {$/;"	f	struct:server.clientConn	typeref:typename:uint64
globalConnID	server.go	/^	globalConnID	util.GlobalConnID$/;"	m	struct:server.Server	typeref:typename:util.GlobalConnID
goerr	conn.go	/^	goerr "errors"$/;"	P	package:errors
handleChangeUser	conn.go	/^func (cc *clientConn) handleChangeUser(ctx context.Context, data []byte) error {$/;"	f	struct:server.clientConn	typeref:typename:error
handleCommonConnectionReset	conn.go	/^func (cc *clientConn) handleCommonConnectionReset(ctx context.Context) error {$/;"	f	struct:server.clientConn	typeref:typename:error
handleFieldList	conn.go	/^func (cc *clientConn) handleFieldList(ctx context.Context, sql string) (err error) {$/;"	f	struct:server.clientConn	typeref:typename:(err error)
handleIndexAdvise	conn.go	/^func (cc *clientConn) handleIndexAdvise(ctx context.Context, indexAdviseInfo *executor.IndexAdvi/;"	f	struct:server.clientConn	typeref:typename:error
handleLoadData	conn.go	/^func (cc *clientConn) handleLoadData(ctx context.Context, loadDataInfo *executor.LoadDataInfo) e/;"	f	struct:server.clientConn	typeref:typename:error
handleLoadStats	conn.go	/^func (cc *clientConn) handleLoadStats(ctx context.Context, loadStatsInfo *executor.LoadStatsInfo/;"	f	struct:server.clientConn	typeref:typename:error
handlePlanRecreator	conn.go	/^func (cc *clientConn) handlePlanRecreator(ctx context.Context, info executor.PlanRecreatorInfo) /;"	f	struct:server.clientConn	typeref:typename:(string, error)
handleQuery	conn.go	/^func (cc *clientConn) handleQuery(ctx context.Context, sql string) (err error) {$/;"	f	struct:server.clientConn	typeref:typename:(err error)
handleQuerySpecial	conn.go	/^func (cc *clientConn) handleQuerySpecial(ctx context.Context, status uint16) (bool, error) {$/;"	f	struct:server.clientConn	typeref:typename:(bool, error)
handleRefresh	conn.go	/^func (cc *clientConn) handleRefresh(ctx context.Context, subCommand byte) error {$/;"	f	struct:server.clientConn	typeref:typename:error
handleResetConnection	conn.go	/^func (cc *clientConn) handleResetConnection(ctx context.Context) error {$/;"	f	struct:server.clientConn	typeref:typename:error
handleStmt	conn.go	/^func (cc *clientConn) handleStmt(ctx context.Context, stmt ast.StmtNode, warns []stmtctx.SQLWarn/;"	f	struct:server.clientConn	typeref:typename:(bool, error)
handshake	conn.go	/^func (cc *clientConn) handshake(ctx context.Context) error {$/;"	f	struct:server.clientConn	typeref:typename:error
handshakeResponse41	conn.go	/^type handshakeResponse41 struct {$/;"	s	package:server
inShutdownMode	server.go	/^	inShutdownMode	bool$/;"	m	struct:server.Server	typeref:typename:bool
initConnect	conn.go	/^func (cc *clientConn) initConnect(ctx context.Context) error {$/;"	f	struct:server.clientConn	typeref:typename:error
insertDataWithCommit	conn.go	/^func insertDataWithCommit(ctx context.Context, prevData,$/;"	f	package:server	typeref:typename:([]byte, error)
isUnixSocket	conn.go	/^	isUnixSocket bool              \/\/ connection is Unix Socket file$/;"	m	struct:server.clientConn	typeref:typename:bool
lastActive	conn.go	/^	lastActive   time.Time         \/\/ last active time$/;"	m	struct:server.clientConn	typeref:typename:time.Time
lastCode	conn.go	/^	lastCode     uint16            \/\/ last error code$/;"	m	struct:server.clientConn	typeref:typename:uint16
lastPacket	conn.go	/^	lastPacket   []byte            \/\/ latest sql query string, currently used for logging error.$/;"	m	struct:server.clientConn	typeref:typename:[]byte
listener	server.go	/^	listener		net.Listener$/;"	m	struct:server.Server	typeref:typename:net.Listener
mu	conn.go	/^	mu struct {$/;"	m	struct:server.clientConn	typeref:typename:struct { sync.RWMutex; cancelFunc context.CancelFunc; }
newBufferedReadConn	buffered_read_conn.go	/^func newBufferedReadConn(conn net.Conn) *bufferedReadConn {$/;"	f	package:server	typeref:typename:*bufferedReadConn
newClientConn	conn.go	/^func newClientConn(s *Server) *clientConn {$/;"	f	package:server	typeref:typename:*clientConn
newConn	server.go	/^func (s *Server) newConn(conn net.Conn) *clientConn {$/;"	f	struct:server.Server	typeref:typename:*clientConn
newPacketIO	packetio.go	/^func newPacketIO(bufReadConn *bufferedReadConn) *packetIO {$/;"	f	package:server	typeref:typename:*packetIO
onConn	server.go	/^func (s *Server) onConn(conn *clientConn) {$/;"	f	struct:server.Server
openSession	conn.go	/^func (cc *clientConn) openSession() error {$/;"	f	struct:server.clientConn	typeref:typename:error
openSessionAndDoAuth	conn.go	/^func (cc *clientConn) openSessionAndDoAuth(authData []byte) error {$/;"	f	struct:server.clientConn	typeref:typename:error
packetIO	packetio.go	/^type packetIO struct {$/;"	s	package:server
parseAttrs	conn.go	/^func parseAttrs(data []byte) (map[string]string, error) {$/;"	f	package:server	typeref:typename:(map[string]string, error)
parseHandshakeResponseBody	conn.go	/^func parseHandshakeResponseBody(ctx context.Context, packet *handshakeResponse41, data []byte, o/;"	f	package:server	typeref:typename:(err error)
parseHandshakeResponseHeader	conn.go	/^func parseHandshakeResponseHeader(ctx context.Context, packet *handshakeResponse41, data []byte)/;"	f	package:server	typeref:typename:(parsedBytes int, err error)
parseOldHandshakeResponseBody	conn.go	/^func parseOldHandshakeResponseBody(ctx context.Context, packet *handshakeResponse41, data []byte/;"	f	package:server	typeref:typename:(err error)
parseOldHandshakeResponseHeader	conn.go	/^func parseOldHandshakeResponseHeader(ctx context.Context, packet *handshakeResponse41, data []by/;"	f	package:server	typeref:typename:(parsedBytes int, err error)
peerHost	conn.go	/^	peerHost     string            \/\/ peer host$/;"	m	struct:server.clientConn	typeref:typename:string
peerPort	conn.go	/^	peerPort     string            \/\/ peer port$/;"	m	struct:server.clientConn	typeref:typename:string
pkt	conn.go	/^	pkt          *packetIO         \/\/ a helper to read and write data in packet format.$/;"	m	struct:server.clientConn	typeref:typename:*packetIO
plannercore	conn.go	/^	plannercore "github.com\/pingcap\/tidb\/planner\/core"$/;"	P	package:github.com/pingcap/tidb/planner/core
prefetchPointPlanKeys	conn.go	/^func (cc *clientConn) prefetchPointPlanKeys(ctx context.Context, stmts []ast.StmtNode) ([]planne/;"	f	struct:server.clientConn	typeref:typename:([]plannercore.Plan, error)
processStream	conn.go	/^func processStream(ctx context.Context, cc *clientConn, loadDataInfo *executor.LoadDataInfo, wg /;"	f	package:server
proxyprotocol	server.go	/^	proxyprotocol "github.com\/blacktear23\/go-proxyprotocol"$/;"	P	package:github.com/blacktear23/go-proxyprotocol
queryDurationHistogramBegin	conn.go	/^	queryDurationHistogramBegin    = metrics.QueryDurationHistogram.WithLabelValues("Begin")$/;"	v	package:server
queryDurationHistogramCommit	conn.go	/^	queryDurationHistogramCommit   = metrics.QueryDurationHistogram.WithLabelValues("Commit")$/;"	v	package:server
queryDurationHistogramDelete	conn.go	/^	queryDurationHistogramDelete   = metrics.QueryDurationHistogram.WithLabelValues("Delete")$/;"	v	package:server
queryDurationHistogramExecute	conn.go	/^	queryDurationHistogramExecute  = metrics.QueryDurationHistogram.WithLabelValues("Execute")$/;"	v	package:server
queryDurationHistogramGeneral	conn.go	/^	queryDurationHistogramGeneral  = metrics.QueryDurationHistogram.WithLabelValues(metrics.LblGene/;"	v	package:server
queryDurationHistogramInsert	conn.go	/^	queryDurationHistogramInsert   = metrics.QueryDurationHistogram.WithLabelValues("Insert")$/;"	v	package:server
queryDurationHistogramReplace	conn.go	/^	queryDurationHistogramReplace  = metrics.QueryDurationHistogram.WithLabelValues("Replace")$/;"	v	package:server
queryDurationHistogramRollback	conn.go	/^	queryDurationHistogramRollback = metrics.QueryDurationHistogram.WithLabelValues("Rollback")$/;"	v	package:server
queryDurationHistogramSelect	conn.go	/^	queryDurationHistogramSelect   = metrics.QueryDurationHistogram.WithLabelValues("Select")$/;"	v	package:server
queryDurationHistogramSet	conn.go	/^	queryDurationHistogramSet      = metrics.QueryDurationHistogram.WithLabelValues("Set")$/;"	v	package:server
queryDurationHistogramShow	conn.go	/^	queryDurationHistogramShow     = metrics.QueryDurationHistogram.WithLabelValues("Show")$/;"	v	package:server
queryDurationHistogramUpdate	conn.go	/^	queryDurationHistogramUpdate   = metrics.QueryDurationHistogram.WithLabelValues("Update")$/;"	v	package:server
queryDurationHistogramUse	conn.go	/^	queryDurationHistogramUse      = metrics.QueryDurationHistogram.WithLabelValues("Use")$/;"	v	package:server
queryTotalCountErr	conn.go	/^	queryTotalCountErr = [...]prometheus.Counter{$/;"	v	package:server
queryTotalCountOk	conn.go	/^	queryTotalCountOk = [...]prometheus.Counter{$/;"	v	package:server
rb	buffered_read_conn.go	/^	rb *bufio.Reader$/;"	m	struct:server.bufferedReadConn	typeref:typename:*bufio.Reader
readOptionalSSLRequestAndHandshakeResponse	conn.go	/^func (cc *clientConn) readOptionalSSLRequestAndHandshakeResponse(ctx context.Context) error {$/;"	f	struct:server.clientConn	typeref:typename:error
readPacket	conn.go	/^func (cc *clientConn) readPacket() ([]byte, error) {$/;"	f	struct:server.clientConn	typeref:typename:([]byte, error)
readTimeout	packetio.go	/^	readTimeout time.Duration$/;"	m	struct:server.packetIO	typeref:typename:time.Duration
salt	conn.go	/^	salt         []byte            \/\/ random bytes used for authentication.$/;"	m	struct:server.clientConn	typeref:typename:[]byte
sequence	packetio.go	/^	sequence    uint8$/;"	m	struct:server.packetIO	typeref:typename:uint8
server	buffered_read_conn.go	/^package server$/;"	p
server	conn.go	/^	server       *Server           \/\/ a reference of server instance.$/;"	m	struct:server.clientConn	typeref:typename:*Server
server	conn.go	/^package server$/;"	p
server	packetio.go	/^package server$/;"	p
server	server.go	/^package server$/;"	p
setBufferedReadConn	packetio.go	/^func (p *packetIO) setBufferedReadConn(bufReadConn *bufferedReadConn) {$/;"	f	struct:server.packetIO
setConn	conn.go	/^func (cc *clientConn) setConn(conn net.Conn) {$/;"	f	struct:server.clientConn
setConn	server.go	/^func (cc *clientConn) setConn(conn net.Conn) {$/;"	f	unknown:server.clientConn
skipInitConnect	conn.go	/^func (cc *clientConn) skipInitConnect() bool {$/;"	f	struct:server.clientConn	typeref:typename:bool
startNetworkListener	server.go	/^func (s *Server) startNetworkListener(listener net.Listener, errChan chan error) {$/;"	f	struct:server.Server
status	conn.go	/^	status       int32             \/\/ dispatching\/reading\/shutdown\/waitshutdown$/;"	m	struct:server.clientConn	typeref:typename:int32
storeerr	conn.go	/^	storeerr "github.com\/pingcap\/tidb\/store\/driver\/error"$/;"	P	package:github.com/pingcap/tidb/store/driver/error
tidbutil	conn.go	/^	tidbutil "github.com\/pingcap\/tidb\/util"$/;"	P	package:github.com/pingcap/tidb/util
tlsConn	conn.go	/^	tlsConn      *tls.Conn         \/\/ TLS connection, nil if not TLS.$/;"	m	struct:server.clientConn	typeref:typename:*tls.Conn
upgradeToTLS	conn.go	/^func (cc *clientConn) upgradeToTLS(tlsConfig *tls.Config) error {$/;"	f	struct:server.clientConn	typeref:typename:error
useDB	conn.go	/^func (cc *clientConn) useDB(ctx context.Context, db string) (err error) {$/;"	f	struct:server.clientConn	typeref:typename:(err error)
user	conn.go	/^	user         string            \/\/ user of the client.$/;"	m	struct:server.clientConn	typeref:typename:string
writeChunks	conn.go	/^func (cc *clientConn) writeChunks(ctx context.Context, rs ResultSet, binary bool, serverStatus u/;"	f	struct:server.clientConn	typeref:typename:(bool, error)
writeChunksWithFetchSize	conn.go	/^func (cc *clientConn) writeChunksWithFetchSize(ctx context.Context, rs ResultSet, serverStatus u/;"	f	struct:server.clientConn	typeref:typename:error
writeColumnInfo	conn.go	/^func (cc *clientConn) writeColumnInfo(columns []*ColumnInfo, serverStatus uint16) error {$/;"	f	struct:server.clientConn	typeref:typename:error
writeEOF	conn.go	/^func (cc *clientConn) writeEOF(serverStatus uint16) error {$/;"	f	struct:server.clientConn	typeref:typename:error
writeError	conn.go	/^func (cc *clientConn) writeError(ctx context.Context, e error) error {$/;"	f	struct:server.clientConn	typeref:typename:error
writeInitialHandshake	conn.go	/^func (cc *clientConn) writeInitialHandshake(ctx context.Context) error {$/;"	f	struct:server.clientConn	typeref:typename:error
writeOK	conn.go	/^func (cc *clientConn) writeOK(ctx context.Context) error {$/;"	f	struct:server.clientConn	typeref:typename:error
writeOkWith	conn.go	/^func (cc *clientConn) writeOkWith(ctx context.Context, msg string, affectedRows, lastInsertID ui/;"	f	struct:server.clientConn	typeref:typename:error
writePacket	conn.go	/^func (cc *clientConn) writePacket(data []byte) error {$/;"	f	struct:server.clientConn	typeref:typename:error
writeReq	conn.go	/^func (cc *clientConn) writeReq(ctx context.Context, filePath string) error {$/;"	f	struct:server.clientConn	typeref:typename:error
writeResultset	conn.go	/^func (cc *clientConn) writeResultset(ctx context.Context, rs ResultSet, binary bool, serverStatu/;"	f	struct:server.clientConn	typeref:typename:(retryable bool, runErr error)
writeStats	conn.go	/^func (cc *clientConn) writeStats(ctx context.Context) error {$/;"	f	struct:server.clientConn	typeref:typename:error
